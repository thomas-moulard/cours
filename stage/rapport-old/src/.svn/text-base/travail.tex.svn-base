
\section{Cahier des charges}


\subsection{But général}

Le but de ce stage est de produire, à partir d'un prototype existant,
une version toujours expérimentale mais diffusable et documentée.  Le
logiciel produit devra permettre de visualiser des automates simples,
d'éditer ses propriétés géométriques et graphiques et d'appliquer les
algorithmes proposés par le TAF-KIT à ces automates.

La documentation utilisateur permettra de découvrir et d'expliquer les
fonctionnalités du logiciel. Cette documentation existant déjà depuis
le premier prototype, il faudra la mettre à jour.

Une documentation développeur est nécessaire. Elle devra présenter la
structure du projet, présenter les différents modules. C'est à dire
expliquer leur utilité, leur fonctionnement et donner des indications
sur l'emplacement de certains calculs.


\subsection{Résultats à obtenir}

Le prototype existant était déjà à une stade avancé, il permettait de:
\begin{itemize}
\item afficher un automates à partir d'un fichier XML
\item modifier cet automate et ces différentes propriétés
\item appliquer des algorithmes à ces automates
\end{itemize}

\vspace{0.3cm}

\subsubsection{Réorganisation du code}

L'un des principaux buts de ce stage est d'organiser le projet en
quatre modules distincts et indépendants. Cette modélisation comporte:

\begin{itemize}
\item le module XML: il permet de charger et sauvegarder des automates
  au format XML (existait déjà dans le prototype).
\item le module géométrique: il gère la manipulation des valeurs
  géométriques, comme les coordonnées d'un état, la forme d'une
  transition, toutes informations se rattachant à la ``forme général''
  de l'automate.
\item le module graphique: il gère la manipulation des propriétés
  graphiques de l'automate, tel que l'emplacement d'un label sur sa
  transition, la couleur d'un état, l'épaisseur d'une transition.
\item le module d'affichage: ce module traduit les propriétés
  géométriques et graphiques pour JGraph.
\end{itemize}

Les modules géométrique et graphique doivent fournir des valeurs par
défaut pour les propriétés qu'ils gèrent.
Les quatre modules forme les différentes étapes par lesquelles un
automate passera.

\begin{itemize}
\item XML: A partir du fichier XML, on construit un objet VJGraph, qui
  représenté notre automate.
\item Puis il passe dans le module géométrique. Si certains éléments
  ne disposent pas de propriétés géométriques, celles-ci sont ajoutées
  avec les valeurs par défaut.
\item De même pour le module graphique et les propriétés associées.
\item Finalement le module d'affichage traduit les propriétés
  précédentes pour JGraph.
\end{itemize}

\subsubsection{Corrections mineures}

Le première version de l'interface graphique pour Vaucanson (VGI) a
été écrite en 2004, depuis le projet Vaucanson a connu plusieurs
modifications que VGI n'a pas suivi. Il faudra donc, un premier temps,
mettre à jour VGI en fonction de Vaucanson 1.0.

\vspace{0.3cm}

En particulier:
\begin{itemize}
\item le format XML a quelque peu changé
\item les algorithmes étaient appliqués grace à l'utilisation
  d'exécutables spéciaux, il serait intéressant de les remplacer par
  ceux du TAF-KIT.
\end{itemize}

\vspace{0.3cm}

De plus, le prototype utilise JGraph pour afficher et manipuler le
graphe de l'automate. Cette bibliothèque ayant évolué depuis
2004, il faudra donc mettre à jour le prototype pour qu'il puisse
utiliser la dernière version de JGraph disponible.

Notons que la nécessité d'utiliser la dernière version de JGraph
disponible est apparu eu cours du stage, et ne semblait pas nécessaire
au début.

Outre les mises à jour, certaines fonctionnalités nécessitent des
modifications.\\
Le prototype de départ permet de sauvegarder les propriétés
géométriques et graphiques du graphe. Mais les unités utilisées ne
sont pas toujours celles désirées. Par ailleurs, certaines propriétés
définies dans le format XML ne sont pas utilisées, ou mal utilisées.

\vspace{0.3cm}

On souhaiterait que:
\begin{itemize}
\item la position d'un état soit exprimée dans une unité indépendante,
  pas en pixel.
\item les unités des angles soit des degrés et non des radians.
\item le label d'une transition soit positionné selon un pourcentage
  (ou 0\% représente le début de la transition et 100\% l'extrémité
  fléchée de la transition) et non pas en utilisant des coordonnées
  absolues.
\item l'opération de centrage de l'automate ne modifie les coordonnées
  des états de l'automate, mais ``déplace'' la fenêtre pour que
  l'automate y soit centré.
\end{itemize}

\subsubsection{Documentation}

Le manuel utilisateur existe déjà, il a été écrit par Pouchet lors de
son stage en 2004. Celui-ci détaille l'utilisation de l'interface
graphique, c'est à dire comment charger et sauvegarder un automate,
comment en créer un nouveau, utiliser les algorithmes et changer les
différentes propriétés. Ce manuel étant complet, il ne nécessitera
probablement pas de modifications.\\

La documentation développeur est quand à elle quasi inexistante.
Certaines parties du code sont documentées mais elles sont rares et
rarement au format Javadoc ou Doxygen. Le code en fait ne demande que
peu de documentation, il est généralement très simple. Cependant un
document expliquant la structure du projet, l'utilité des différents
modules et les classes qui les composent, faciliterait la prise en
main du code pour les étudiants qui seraient amenés a y travailler.

\section{Compte-rendu d'activité}

\subsection{Conception}

Avec l'aide de mon maître de stage et de Louis-Noel Pouchet, une
modélisation a été décidé. Cette modélisation est basé sur les
différentes étapes que se détachent quand on analyse notre manière de
dessiner un automate.

Trois étapes se détachent en particulier:
\begin{enumerate}
\item On décide de la forme de l'automate, c'est à dire on place les
  états, on décide de la forme de transition, l'emplacement des labels.
\item Puis on décide de son apparence, certains états doivent être
  colorés, l'épaisseur des transitions.
\item Le rendu final, ou l'affichage à l'écran.
\end{enumerate}

Dans le cas de notre logiciel, l'automate est contenu dans un fichier
XML, il faut donc un module dont la tache est de lire se fichier et de
créer un objet manipulable par le reste du programme.

Par ailleurs, l'affichage est géré par JGraph. Il n'est donc pas
nécessaire d'écrire un module d'affichage, mais plutot un module
chargé de traduire les différentes propriétés graphiques et
géométriques de l'automate.

Au final, la modélisation présentée par la figure \ref{fig:mod}, a été
obtenue.

\begin{figure}[h]
  \centering
  %%FIXME: faire l'uml des quatre packages.
  \caption{Modélisation général du projet}
  \label{fig:mod}
\end{figure}


\subsection{Modules}

\subsubsection{XML}

Le module XML utilisé est celui déjà présent dans le premier
prototype. Quelques modifications sont cependant nécessaire pour que
le module soit à jour par rapport à l'état actuel du format XML.

Ces mises à jour consistent globalement à changer le nom de certains
attributs, et d'utiliser les modules Geometry et Drawing pour extraire
les données à stocker dans le fichier XML.


\subsubsection{Module géométrique et graphique}

Les modules géométriques et graphiques sont en tout point
semblables. Ils ne différent que par l'ensemble des propriétés qu'ils
gèrent.

Le module Geometry permet la manipulation des propriétés géométriques
de l'automate, et en particulier celles de ses états et
transitions. Chaque état ou transition possède deux tables
associatives contenant leurs propriétés géométriques et graphiques.

Les valeurs contenues par ces tables sont extraites et insérées grâce
à la classe GeometryProperties qui fournit un ensemble de méthodes
statiques, ainsi que des valeurs par défaut pour chaque propriété.
Les types des valeurs étant assez variés (entier, chaine de caractère,
énumération), toutes les données sont stockées sous forme de chaine de
caractère dans la table associative.

Ainsi d'une part, leur sauvegarde au format XML est facilité et
d'autre part la classe GeometryProperties se charge de fournir les
données vers les types concrets. Ainsi on pourra dans le futur
modifier la manière dont les propriétés sont stockés en mémoire sans
modifier trop de code. Il suffira d'adapter les différentes méthodes
statiques de la classe GeometryProperties.

La figure \ref{fig:geo} présentent quelques exemples de méthodes que
l'on peut trouver dans la classe GeometryProperties.

\begin{figure}[h]
\begin{lstlisting}
public final static String TRANSITIONTYPE = "transitionType";
public static void setTransitionType(Transition e, String type)
{
  Map geometry = e.geometry_get();

  if (type != null || type.equals(LINE) || type.equals(ARCL) ||
      type.equals(ARCR) || type.equals(CURVE))
       geometry.put(TRANSITIONTYPE, type);
  else
       geometry.put(TRANSITIONTYPE, TRANSITIONTYPEDEFAULT);
}

public static String getTransitionType(Transition e)
{
  Map geometry = e.geometry_get();
  String type = (String) geometry.get(TRANSITIONTYPE);
  return type;
}

// Values for transitionType
public final static String LINE = "line";
public final static String ARCL = "arcL";
public final static String ARCR = "arcR";
public final static String CURVE = "curve";
public final static String TRANSITIONTYPEDEFAULT = LINE;
\end{lstlisting}

  \caption{Extrait de code de la classe GeometryProperties}
  \label{fig:geo}
\end{figure}

Une fois les classes GeometryProperties et DrawingProperties créées,
il a fallu mettre à jour l'ensemble du code pour qu'il utilise ces
méthodes. Ainsi le module XML et l'ensemble des classes gérant
l'interaction avec l'utilisateur ont été adaptés pour utiliser ces
méthodes.


\subsubsection{Module d'affichage}

Le module d'affichage est composé d'un ensemble de classe chargées de
fournir à JGraph des indications sur comment dessiner le graphe de
l'automate, ou qui parfois étendent le comportement de JGraph en
prenant en charge elles même certaines parties du dessin.

Ainsi dans ce module on trouvera les classes:
\begin{itemize}
\item Router: à partir des informations géométriques d'une transition,
  principalement sa forme (ligne, arc), cette classe fournit une suite
  de points par lesquelles le tracé de la transition doit passer.
\item StateView: cette classe prend en charge l'affichage d'un état.
\item TransitionView: cette classe ne gère que l'affichage d'un label
  associé à une transition. Cependant, elle pourrait a l'avenir
  prendre en charge l'affichage de la transition.
\end{itemize}




\end{document}
